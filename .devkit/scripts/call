#!/usr/bin/env bash
set -e

# source in helper functions
source "$( dirname "${BASH_SOURCE[0]}" )/helpers/helpers.sh"


# Check if context parameter is provided
if [ -z "$1" ]; then
    log "Error: Missing context parameter"
    log "Usage: ./call '{\"version\":\"0.0.1\",\"context\":{...}}' '{\"signature\":\"(uint256,string,...)\",\"args\":\"(5,\"hello\",...)\"}'"
    exit 1
fi

# Check if params parameter is provided
if [ -z "$2" ]; then
    log "Error: Missing params parameter"
    log "Usage: ./call '{\"version\":\"0.0.1\",\"context\":{...}}' '{\"signature\":\"(uint256,string,...)\",\"args\":\"(5,\"hello\",...)\"}'"
    exit 1
fi

# Parse the JSON context and params
CONTEXT="$1"
PARAMS="$2"

# Check for required tools
ensureJq
ensureYq


if ! command -v cast &> /dev/null; then
    log "Error: cast not found. Please run 'avs create' first."
    exit 1
fi

# Extract signature and args from params JSON
SIGNATURE=$(echo "$PARAMS" | jq -r '.signature')
ARGS=$(echo "$PARAMS" | jq -r '.args')

# Validate signature and args
if [ "$SIGNATURE" == "null" ] || [ -z "$SIGNATURE" ]; then
    log "Error: Missing signature in params"
    log "Params must be in the format: '{\"signature\":\"(uint256,string)\",\"args\":\"(5,\"hello\")\"}'"
    exit 1
fi

if [ "$ARGS" == "null" ] || [ -z "$ARGS" ]; then
    log "Error: Missing args in params"
    log "Params must be in the format: '{\"signature\":\"(uint256,string)\",\"args\":\"(5,\"hello\")\"}'"
    exit 1
fi

# Format the signature to f(<signature>)
FORMATTED_SIGNATURE="f($SIGNATURE)"

# Generate the payload using cast abi-encode
set +e
PAYLOAD=$(cast abi-encode "$FORMATTED_SIGNATURE" "$ARGS" 2> >(tee >&2))
CAST_EXIT_CODE=$?
set -e

if [ $CAST_EXIT_CODE -ne 0 ]; then
    log ""
    log "Error: Failed to encode arguments using cast abi-encode"
    log "Signature: $SIGNATURE"
    log "Arguments: $ARGS"
    exit 1
fi

# Extract required values from context
ENVIRONMENT=$(echo "$CONTEXT" | jq -r '.context.name')
L2_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l2.rpc_url')
PRIVATE_KEY_APP=$(echo "$CONTEXT" | jq -r '.context.app_private_key')
AVS_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.avs.address')
TASK_MAILBOX_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l2.task_mailbox')

# Get executor operator set ID from environment YAML file
ENVIRONMENT_YAML_FILE=".hourglass/context/${ENVIRONMENT}.yaml"
if [ ! -f "$ENVIRONMENT_YAML_FILE" ]; then
    log "Error: AVS environment file ${ENVIRONMENT_YAML_FILE} does not exist"
    exit 1
fi

EXECUTOR_OPERATOR_SET_ID=$(yq -r '.executor.operatorSetId' "$ENVIRONMENT_YAML_FILE")

# Validate required fields exist in JSON
if [ "$ENVIRONMENT" == "null" ] || [ -z "$ENVIRONMENT" ]; then
    log "Error: Missing name (environment) in context"
    exit 1
fi

if [ "$L2_RPC_URL" == "null" ] || [ -z "$L2_RPC_URL" ]; then
    log "Error: Missing L2_RPC_URL in context"
    exit 1
fi

if [ "$PRIVATE_KEY_APP" == "null" ] || [ -z "$PRIVATE_KEY_APP" ]; then
    log "Error: Missing app_private_key in context"
    exit 1
fi

if [ "$AVS_ADDRESS" == "null" ] || [ -z "$AVS_ADDRESS" ]; then
    log "Error: Missing avs.address in context"
    exit 1
fi

if [ "$EXECUTOR_OPERATOR_SET_ID" == "null" ] || [ -z "$EXECUTOR_OPERATOR_SET_ID" ]; then
    log "Error: Missing executor.operatorSetId in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

# Validate Ethereum addresses
if [[ ! "$AVS_ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
    log "Error: AVS_ADDRESS must be a valid Ethereum address (0x followed by 40 hex characters)"
    exit 1
fi

if [ "$TASK_MAILBOX_ADDRESS" == "null" ] || [ -z "$TASK_MAILBOX_ADDRESS" ]; then
  log "Error: Missing eigenlayer.l2.task_mailbox in context"
  exit 1
fi

if [[ ! "$TASK_MAILBOX_ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
  log "Error: TASK_MAILBOX_ADDRESS must be a valid Ethereum address"
  exit 1
fi

# Validate payload is a hex string
if [[ ! "$PAYLOAD" =~ ^0x[a-fA-F0-9]+$ ]]; then
    log "Error: Generated payload must be a hex string (0x followed by hex characters)"
    log "Got: $PAYLOAD"
    exit 1
fi

log "Creating task on the TaskMailbox contract..."
log "Using payload encoded from signature: $SIGNATURE, args: $ARGS"

# Capture the last bytes32 printed by forge as the task hash
RAW_OUT_FILE="$(mktemp)"
# run your make target and tee its stdout so we can parse it
cd ./.devkit/contracts
PRIVATE_KEY_APP="${PRIVATE_KEY_APP}" make create-task \
  RPC_URL="${L2_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" TASK_MAILBOX_ADDRESS="${TASK_MAILBOX_ADDRESS}" \
  AVS_ADDRESS="${AVS_ADDRESS}" EXECUTOR_OPERATOR_SET_ID=${EXECUTOR_OPERATOR_SET_ID} \
  PAYLOAD="${PAYLOAD}" | tee "${RAW_OUT_FILE}"
cd - >/dev/null

log "Task created successfully." 

# Capture taskHash from raw output
TASK_HASH=$(
  awk '/Created task with hash:/{getline; print;}' "${RAW_OUT_FILE}" \
  | grep -Eo '0x[a-fA-F0-9]{64}' | head -n1
)
if [[ ! "$TASK_HASH" =~ ^0x[a-fA-F0-9]{64}$ ]]; then
  log "Error: could not parse taskHash from create-task output"
  exit 1
fi
rm -f "${RAW_OUT_FILE}"

# Discovered taskHash, waiting for verification
log "Task hash: ${TASK_HASH}"
log "Waiting for TaskVerified..."

# Start block just after creation to avoid missing the event
FROM_BLOCK=$(cast block-number --rpc-url "$L2_RPC_URL")

#  30 minutes if sleep=5
MAX_ATTEMPTS=360
SLEEP=5
FOUND=0

# Poll for TaskVerified() logs
for ((i=1; i<=MAX_ATTEMPTS; i++)); do
  EVENT=$(cast logs \
    --rpc-url "$L2_RPC_URL" \
    --address "$TASK_MAILBOX_ADDRESS" \
    --from-block "$FROM_BLOCK" \
    --to-block latest \
    "TaskVerified(address,bytes32,address,uint32,bytes,bytes)" \
    "$TASK_HASH" --json)

  if [ -n "$EVENT" ] && [ "$EVENT" != "[]" ]; then
    echo "$EVENT" | jq -r '.[0].data' | while read -r DATA; do
      DECODED="$(cast --abi-decode "(uint32,bytes,bytes)" "$DATA")"
      echo "TaskVerified received"
      echo "$DECODED"
    done
    FOUND=1
    break
  fi
  sleep $SLEEP
done

if [ $FOUND -eq 0 ]; then
  echo "Timeout: TaskVerified not seen"
  exit 1
fi
